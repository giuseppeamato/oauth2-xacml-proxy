OAuth2 XACML Ballerina Proxy Connector

# Module Overview

This connector acts as a proxy, allows you to add a security layer for unprotected resources, verifying oauth2 token passed as a authorization bearer token. Optionally the connector can perform an XACML query to check permission policies.
 
It's also possible to manipulate both the request sent by the caller, before being forwarded to the destination endpoint, and the response generated by the remote service, before being sent back to the caller.

This component does not perform token generation, but simply checks its validity. A typical use case is a SPA that independently obtains an oauth2 token following a selected grant type, then calls in a single sign on context various REST backend services protected with this connector.

Tested with WSO2 Identity Server 5.8.

## Compatibility

|                          |    Version     |
|:------------------------:|:--------------:|
| Ballerina Language       | 1.0.0          |
| XACML                    | 3.0            |

## Getting Started

You can pull the module from Ballerina Central using the command:
```shell
$ ballerina pull pz8/oauth2_xacml
```

Import the `pz8/oauth2_xacml` module into your Ballerina project.
```java
import pz8/oauth2_xacml;
```

Set the proper attributes in the configuration object, usually filled in a toml configuration file, and instantiate the connector
```java
oauth2_xacml:GatewayConfiguration gatewayConf = {
   idsEndpoint: config:getAsString("oauth2_xacml.endpoint"),
   idsUsername: config:getAsString("oauth2_xacml.username"),
   idsPassword: config:getAsString("oauth2_xacml.password"),
   truststorePath: config:getAsString("oauth2_xacml.truststorePath"),
   truststorePassword: config:getAsString("oauth2_xacml.truststorePassword"),    
   idsIntrospectPath: config:getAsString("oauth2_xacml.introspectPath"),
   idsUserInfoPath: config:getAsString("oauth2_xacml.userInfoPath"),
   idsAuthorizationPath: config:getAsString("oauth2_xacml.authorizationPath")
};

oauth2_xacml:Client oauth2Client = new(gatewayConf);
```
Concrete example of the configuration file:
```ballerina
[oauth2_xacml]
endpoint="https://localhost:9443"
username="@encrypted:{+HS3IPMC5RjPiipvk4pXi7dEYosFtIK7RG3iD4i6UAw=}"
password="@encrypted:{ha6s2HX8Vn3efsKlCWZ6nlD932F2qNw9hTbFS8EOjSM=}"
introspectPath="/oauth2/introspect"
userInfoPath="/oauth2/userinfo?schema=openid"
authorizationPath="/api/identity/entitlement/decision/pdp"
truststorePath="./ballerinaTruststore.p12"
truststorePassword="ballerina"    

[b7a.log]
level="DEBUG"
```
+ `endpoint`: the base URL of the Identity Server
+ `username`: username for the Identity Server
+ `password`: password for the Identity Server
+ `introspectPath`: relative path to invoke the OAuth introspection endpoint and validate the token
+ `userInfoPath`: relative path to invoke the User Profile Information service
+ `authorizationPath`: relative path to invoke the Policy Decision Point entitlement service
+ `truststorePath`: path to the .p12 truststore file
+ `truststorePassword`: password for truststore file

In your module create a resource to proxy the remote service and invoke the `gateway` method of the connector.
```java
@http:ResourceConfig {
   methods: ["GET"],
   path: "/test"
}
resource function startProcess(http:Caller caller, http:Request request) returns error? {
   var result = oauth2Client->gateway(caller, request, testClient, "/test", true, ());
}
```

The signature of the `gateway` function expects the following parameters:
```java
public remote function gateway(http:Caller caller, http:Request request, 
    http:Client targetClient, string serviceUrl, 
    boolean authorizationEnabled, 
    (function (http:Request, json) returns (http:Request))|() transformCallback)
```
+ caller - the `http:Caller` that makes the request
+ request - the `http:Request` object
+ targetClient - an `http:Client` configured in your project for the remote endpoint
+ serviceUrl - path of the remote resource
+ authorizationEnabled - if `true` the connector makes an xacml query to the policy decision point, passing as a parameters the current logged username, the path of the remote resource and the http request method
+ transformCallback - callback function called before forwarding payload to remote endpoint. The `nil` value `()` represents the absence of callback function to manipulate the request.

# Transform request

To manipulate di request before it's sent to the proxied service, you need to pass a callback function to the connector. The signature of the callback function expects the `http:Request` object and a json object that represents the user data obtained through the OAuth2 token.

For example:

```java
@http:ResourceConfig {
   methods: ["GET"],
   path: "/test"
}
resource function startProcess(http:Caller caller, http:Request request) returns error? {
   string remoteUrl = "/test";
   var result = oauth2Client->gateway(caller, request, testClient, remoteUrl, true, setHeader);
}

function setHeader(http:Request request, json userInfo) returns http:Request {
    request.addHeader("x-sso-roles", userInfo.groups.toString());
    return request;
}
```

# Transform response

If you need to manipulate the response before it's sent back to the caller, you have to invoke the `process` method
instead of `gateway`. The `process` method performs all the operations of the other except the reply to the caller, giving you the opportunity to make the appropriate transformations.
The `process` method expects the same parameters of the `gateway` method, but returns the `http:Response` related to the remote service or an error object. After the transformations you have to call the `responseToCaller` method on the oauth2client connector.

For example:

```java
@http:ResourceConfig {
   methods: ["GET"],
   path: "/test"
}
resource function startProcess(http:Caller caller, http:Request request) returns error? {
   string remoteUrl = "/test";
   var response = oauth2Client->process(caller, request, testClient, serviceUrl, true, ());
   if (response is http:Response) {
      json payload = check response.getJsonPayload();
      string jsonReplaced = stringutils:replace(payload.toJsonString(), "${title}", "Custom Title");
      response.setJsonPayload(check jsonReplaced.fromJsonString());
   }
   var clientResult = oauth2Client->responseToCaller(caller, response);
}
```
